{"config":{"lang":["pt"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Docker","text":"<p>Documenta\u00e7\u00e3o do projeto: https://docker.com/docs</p> <p>C\u00f3digo fonte dessa p\u00e1gina: https://github.com/raffaeldutra/docker.raffaeldutra.github.io</p>"},{"location":"#o-que-e","title":"O que \u00e9?","text":"<p>Docker \u00e9 um software aberto que pode ser instalado para Linux (grande n\u00famero de distribui\u00e7\u00f5es), Windows e MacOS, com o objetivo de agilizar e facilitar o desenvolvimento de aplica\u00e7\u00f5es em ambientes totalmente isolados e criando uma forma padronizada de como entregar software.</p> <p>Antigamente, tinhamos uma grande barreira de como desenvolvedores e operadores lidavam com a entrega do software. Desenvolvedores criavam software e n\u00e3o estavam preocupados de que forma ele seria entregue para o time de opera\u00e7\u00f5es, por\u00e9m o time de opera\u00e7\u00f5es prezava pelo funcionamento correto das aplica\u00e7\u00f5es, criando assim um atrito entre ambos os times.</p>"},{"location":"#infraestrutura","title":"Infraestrutura","text":"<p>Quando utilizamos Docker, temos todos os passos de como a infraestrutura para este software foi criada em uma \u00fanica imagem, viabilizando e muito em como o time de opera\u00e7\u00f5es ir\u00e1 colocar este software em funcionamento. quais os diret\u00f3rios, arquivos, scripts, comandos e servi\u00e7o que devem ser criados e executados para que o software funcione.</p> <p>Uma vez definida toda esta infaestrutura, empacotamos este software em uma imagem e esta imagem pode ser executada em qualquer Sistema Operacional devido ao modelo que Docker utiliza de padroniza\u00e7\u00e3o de como aquele software deve ser constru\u00eddo.</p> <p>Para rodar estas imagens precisamos criar os containers e estes containers \u00e9 que v\u00e3o de fato rodar sua aplica\u00e7\u00e3o e fazer ela ganhar vida. Quando o container iniciar, Docker automaticamente isolar\u00e1 os recursos utilizados por este container, como mem\u00f3ria, processamento e disco no hardware, garantindo assim a exist\u00eancia dos demais softwares com diferentes tecnologias sem a influ\u00eancia dos demais containers em execu\u00e7\u00e3o.</p> <p>Toda vez que for iniciado um novo container, apenas o processo \u00e9 criado, levando com ele todas bibliotecas e configura\u00e7\u00f5es necess\u00e1rias para que este processo fique completamente isolado, criando um overhead min\u00edmo, o que n\u00e3o acontece quando utilizamos M\u00e1quinas Virtuais (veremos um desenho sobre overhead e a diferen\u00e7a entre M\u00e1quinas Virtuais e containers mais \u00e0 frente).</p> <p>Quando estamos falando em Hardware</p> <p>Estamos falando do seu laptop, desktop ou servidor. O importante \u00e9 entender que todos os containers feitos em Docker s\u00e3o isolados e que ao executar o comando <code>ps -faux</code> voc\u00ea ver\u00e1 estes containers como sendo apenas processos da sua m\u00e1quina.</p>"},{"location":"docker-compose/","title":"Docker Compose","text":"<p>Docker Compose \u00e9 a maneira de declararmos v\u00e1rios containers para nossa aplica\u00e7\u00e3o e ele \u00e9 \"invocado\" pelo comando docker-compose. Ent\u00e3o com isso imaginamos que temos uma aplica\u00e7\u00e3o escrita em PHP que utiliza banco de dados MySQL para guardarmos nossos dados.</p> <p>Exemplos:</p> <ol> <li>temos uma aplica\u00e7\u00e3o escrita em PHP</li> <li>temos um banco de dados em MySQL</li> </ol> <p>ou ainda, o t\u00e3o famoso Wordpress:</p> <ol> <li>temos o Wordpress</li> <li>temos o banco de dados do Wordpress</li> </ol> <p>N\u00e3o importa aqui o exemplo, o que importa \u00e9 a ideia de termos \"coisas separadas, vamos simplificar a ideia nisso apenas.</p> <p>Docker Compose \u00e9 parecido com o Dockerfile que vimos antes, mas ele \u00e9 escrito em um formato YAML (YAML Ain't Markup Language) para que possamos declarar nossa aplica\u00e7\u00e3o e tudo mais que \u00e9 utiliza por ela, como volumes, portas, depend\u00eancia de um outro container, imagem, vari\u00e1veis de ambiente e etc, ou sejam nada quase diferente do que o Dockerfile neste ponto, por\u00e9m apenas parece, ele faz muito mais coisa.</p> <p>Vejamos um exemplo de Docker Compose para termos uma ideia.</p> <pre><code>1. version: '3.3'\n2.\n3. services:\n4.   db:\n5.     image: mysql:5.7\n6.     volumes:\n7.       - db_data:/var/lib/mysql\n8.     restart: always\n9.     environment:\n10.       MYSQL_ROOT_PASSWORD: somewordpress\n11.       MYSQL_DATABASE: wordpress\n12.       MYSQL_USER: wordpress\n13.       MYSQL_PASSWORD: wordpress\n14.\n15.   wordpress:\n16.     depends_on:\n17.       - db\n18.     image: wordpress:latest\n19.     ports:\n20.       - \"8000:80\"\n21.     restart: always\n22.     environment:\n23.       WORDPRESS_DB_HOST: db:3306\n24.       WORDPRESS_DB_USER: wordpress\n25.       WORDPRESS_DB_PASSWORD: wordpress\n26. volumes:\n27.    db_data:\n</code></pre> <p>Isso mesmo, linha por linha eu vou explicar:</p> <p>Linha 1: vers\u00e3o utilizada do Docker Compose, e isso vai variar conforme a vers\u00e3o que voc\u00ea tem instalada na sua m\u00e1quina.</p> <p>Linha 3: estamos dizendo que estamos iniciando um servi\u00e7o e tudo abaixo dessa linha faz parte deste servi\u00e7o.</p> <p>Linha 4: nome que estamos dando para este container, no nosso caso \u00e9 um simples \"db\", mas poderia ser chamado de banco, database e etc.</p> <p>Linha 5: imagem utilizada do mysql com sua respectiva vers\u00e3o.</p> <p>Linha 6 e 7: volume que \u00e9 utilizado para nosso banco de dados, veja que este valor est\u00e1 ligado diretamente com a defini\u00e7\u00e3o das linhas 26 e 27.</p> <p>Linha 8: se algo acontecer com o container, ele por default ir\u00e1 reiniciar sempre.</p> <p>Linha 9 at\u00e9 linha 13: s\u00e3o vari\u00e1veis de ambiente que ser\u00e3o utilizadas para acessar o container que roda nosso banco de doados</p> <p>Linha 15: nome do nosso container, que mais uma vez poderia ser o nome de qualquer coisa.</p> <p>Linha 16: dizemos que para levantar este container, precisamos do container chamado db antes em funcionamento.</p> <p>Linha 18: imagem utilizada do Wordpress com sua respectiva vers\u00e3o, no caso latest significa \u00faltima.</p> <p>Linha 19 e 20: defini\u00e7\u00e3o de portas, ou seja, queremos acessar na porta 8000 da nossa m\u00e1quina a porta 80 que roda l\u00e1 dentro do container.</p> <p>Linha 21: se algo acontecer com o container, ele por default ir\u00e1 reiniciar sempre.</p> <p>Linha 22 at\u00e9 25:\u00e3o vari\u00e1veis de ambiente que ser\u00e3o utilizadas para acessar o container que roda nosso Wordpress.</p> <p>Linha 26 e 27: defini\u00e7\u00e3o do volume que usamos nas linhas 6 e 7.</p>"},{"location":"installing/","title":"Instalando","text":"<p>Para instalar Docker CE (Community Edition), voc\u00ea precisa de vers\u00e3o 64 bits.</p> <p>Agora para instalarmos isso vai depender de bastante coisa, por\u00e9m vamos trabalhar de maneira gen\u00e9rica, ent\u00e3o segue duas formas:</p> <p>Forma 1.</p> <ul> <li>Uma m\u00e1quina virtual (VM): pode ser utilizando Virtualbox, VMware, tanto faz.</li> <li>VM com acesso para internet.</li> <li>VM com placa em modo bridge.</li> <li>Curl instalado sudo apt-get install curl --yes</li> </ul> <p>Aten\u00e7\u00e3o: esta VM precisa ter uma interface em modo bridge para ter acesso aos containers que iremos estudar durante o workshop</p> <p>Forma 2.</p> <ul> <li>Se voc\u00ea j\u00e1 for usu\u00e1rio Linux nativo, pode realizar diretamente sem necessitar de m\u00e1quina virtual.</li> </ul>"},{"location":"installing/#formas-de-instalar-docker","title":"Formas de instalar docker","text":"<p>Existem algumas formas de instalar Docker, por\u00e9m vamos ver as duas mais comuns.</p>"},{"location":"installing/#maneira-1","title":"Maneira 1","text":"<p>Remova a vers\u00e3o antiga (caso tiver).</p> <pre><code>sudo apt-get remove docker docker-engine docker.io\n</code></pre> <p>Instale os pacotes que permitem que o apt possa utilizar reposit\u00f3rios com https</p> <pre><code>sudo apt-get install \\\n    apt-transport-https \\\n    ca-certificates \\\n    curl \\\n    software-properties-common\n</code></pre> <p>Agora instale a chave GPG do Docker</p> <p>Preste aten\u00e7\u00e3o na sua distribui\u00e7\u00e3o abaixo</p> <pre><code>curl -fsSL https://download.docker.com/linux/$(lsb_release -is | tr '[:upper:]' '[:lower:]')/gpg | sudo apt-key add -\n</code></pre> <p>Adicione o reposit\u00f3rio.</p> <pre><code>sudo add-apt-repository \"deb [arch=amd64] https://download.docker.com/linux/ubuntu (lsb_release -cs) stable\"\n</code></pre> <p>Vamos atualizar o index dos pacotes apt</p> <pre><code>sudo apt-get update\n</code></pre> <p>Vamos instalar a \u00faltima vers\u00e3o do Docker Community Edition</p> <pre><code>sudo apt-get install docker-ce\n</code></pre> <p>Vamos testar se est\u00e1 tudo funcionando</p> <pre><code>sudo docker container run hello-world\n</code></pre>"},{"location":"installing/#maneira-2","title":"Maneira 2","text":"<p>Dependendo da vers\u00e3o do seu Ubuntu, Debian e etc, pode Baixe Docker com o comando m\u00e1gico (funciona somente em Sistemas Operacionais). Windows, sorry :-)</p> <pre><code>curl -fsSL https://get.docker.com/ | sh\nsudo usermod -aG docker &lt;usuario&gt;\n</code></pre> <p>Depois disso, voc\u00ea precisa fazer logoff para funcionar com este usu\u00e1rio.</p>"},{"location":"installing/#como-obter-docker-para-outros-sistemas","title":"Como obter Docker para outros sistemas?","text":"<ul> <li>Link para documenta\u00e7\u00e3o oficial<ul> <li>Instalando em Windows</li> <li>Instalando em Debian</li> <li>Instalando em Ubuntu</li> <li>Instalando em MacOS</li> </ul> </li> </ul>"},{"location":"c1/cleaning/","title":"Limpando o que n\u00e3o \u00e9 usado","text":"<p>Voc\u00ea ir\u00e1 notar que depois de muitos comandos para l\u00e1 e para c\u00e1, muitas coisas ficaram para tr\u00e1s, como containers parados, imagens n\u00e3o \"funcionais\" e etc. Para limparmos essa bagun\u00e7a, execute o comando abaixo:</p> <pre><code>docker system prune\n</code></pre> <p>Voc\u00ea ir\u00e1 receber algo do tipo:</p> <pre><code>rafael @ nazgul ~\n\u2514\u2500 $ \u25b6 docker system prune\nWARNING! This will remove:\n        - all stopped containers\n        - all networks not used by at least one container\n        - all dangling images\n        - all build cache\nAre you sure you want to continue? [y/N] y\nDeleted Containers:\n7ed46aef747a7726285ecde46f7fbcd37fb932e1d106a5552a5ec6205cb45f2f\n847d0f4d36f2b295804778ea69d33e3f9e4fbaf968fec9c244126955aba50e9b\na47ad7b67d69698896b290f6daf7e4f65760a38a15a2ba10ed87e3d33ecc1032\ndfcbe65a5ae70c204abec0f8a224d1373804c64a927ada38f09d773aca29020d\n62126d53d79232d6bd687a68990e5ef05b5e9e3f8e678286994e2370e9c6faed\nb9427ac05e95b6a7256dec9d53578ed1d05c6792333917e69be5f71e074a5a50\n076a96cd455ad7d7a97d2756b8bd1768aa474fccb7c73022fc94aa013ff0a274\nafdf2d8219b5917ba9e110657e0364d7c9f407e1871631669912b626bf6033a8\n498da065d6e5f19e27828336a9c0a72dcce284de7ccf21e469266fb8a67a7e3d\na5dadf4de7549d7923aa9a00b5851813efd8ac7f1dd2410397865bc64955af57\n365ae9546d039aba3e8df2abc5132310e2ec67f54bc20e0ac6c2e5b35e55052a\n5c0e6625bda621820dc18479231a7018d7c11dd6fa933c0c4842e575041a34a0\nf0e9646730cd1bd8360e2fa2a71c8bfb3910968047acffe01f772c88f75b940e\n\nDeleted Images:\ndeleted: sha256:2d92e5d5adbe5e207b36d93bd14d8b75919d4a118c86f4b137a9c46481b98fef\ndeleted: sha256:8ae3118b00c274114fd91dc96628b845e0ff4722717bfdf343c2207bad1ec01f\n\nTotal reclaimed space: 70.62MB\n</code></pre>"},{"location":"c1/interacting-containers/","title":"Interagindo com containers","text":"<p>At\u00e9 agora fizemos alguns poucos exemplos, vamos entrar de fato em um container e trabalhar um pouco com ele.</p> <p>Execute o seguinte comando:</p> <pre><code>docker container run --interactive --tty --publish 45000:80 nginx /bin/bash\n</code></pre> <ul> <li>Edite o arquivo /usr/share/nginx/html/index.html com o vim</li> </ul> <p>O que aconteceu?</p> <pre><code>apt-get update &amp;&amp; apt-get install vim --yes\n</code></pre> <p>Vamos acessar novamente o nosso web server na porta 45000 e percebemos que? Pois ent\u00e3o, ao entrarmos dentro de um container, n\u00f3s \"perdemos\" a execu\u00e7\u00e3o de comando/entrypoint que a imagem foi destinada e para entedemos melhor, vamos ver como esta imagem do nginx foi criada. Para isso n\u00f3s iremos acessar um reposit\u00f3rio desta imagem no Github.</p> <p>Docker Hub \u00e9 um reposit\u00f3rio aberto de imagens de onde todas imagens p\u00fablicas, inclusive esta que estamos usando neste momento, est\u00e3o sendo utilizadas. Voc\u00ea pode criar sua propria imagem e envia-l\u00e1 sem problema algum para o Docker Hub, apenas atente para n\u00e3o deixar nenhum tipo de credential \"boiando\" por l\u00e1.</p> <p>Vamos ent\u00e3o abrir o reposit\u00f3rio do Nginx e ver de mais perto o que estamos conversando.</p> <p>Ao abrirmos o arquivo de como \u00e9 feita a imagem, percebemos na \u00faltima que existe um comando chamado CMD [\"nginx\", \"-g\", \"daemon off;\"]. Este comando nos diz o seguinte em uma tradu\u00e7\u00e3o livre \"quando voc\u00ea rodar um novo container eu automaticamente vou invocar o comando nginx -g daemon para voc\u00ea\". No nosso caso, acessamos o container de modo que estamos \"brincando\" com ele e este comando n\u00e3o foi executado pois ele somente \u00e9 dispararado quando n\u00e3o passamos um novo par\u00e2metro para ele, que foi o /bin/bash.</p> <p>Dockerfile \u00e9 este arquivo que estamos acessando neste momento e entendendo sua \"planta baixa\" de como funciona sua imagem e que tamb\u00e9m entraremos para falar somente dele.</p> <p>Voltamos ao nosso problema inicial. Percebemos que ao entrar no container que est\u00e1 rodando Nginx ele n\u00e3o subiu o servi\u00e7o e com isso nos vem a pergunta simples, como levantamos o servi\u00e7o do nginx? simples, digite o comando nginx e acesse novamente o endere\u00e7o http://localhost:45000</p> <p>Trabalhar com containers no in\u00edcio pode ser t\u00e3o trabalhoso como de fato \u00e9 :-)</p> <p>Agora acesse novamente http://localhost:45000 e veja sua nova p\u00e1gina.</p> <p>Por\u00e9m n\u00f3s podemos fazer algo melhor sem \"encostar\" no container, algo interessante como volumes que veremos mais em breve.</p> <p>Quando iniciamos um container novo, podemos instalar pacotes, editar/apagar/criar arquivos e outras coisas mais, por\u00e9m temos um problema ao sair do container de forma tradicional pelo terminal pois o container automaticamente ser\u00e1 parado assim que voc\u00ea digitar exit ou der control d. Para resolvermos este problema, podemos utiliazar a combina\u00e7\u00e3o de teclas como control p q, isso far\u00e1 com que nosso container continue rodando normalmente e ele n\u00e3o ir\u00e1 parar.</p> <p>Utilizando este conjunto de teclas, nos vem a seguinte pergunta: \"E se eu quero retornar ao container, como fa\u00e7o?\".</p> <pre><code>docker attach &lt;id do container&gt; ou &lt;nome&gt;\n</code></pre> <p>Excelente, tudo funcionando como esperado, mas e se eu quero apenas listar algum arquivo ou quem sabe visualizar e assim por diante? ou seja, quero apenas fazer algo breve no meu container?</p> <pre><code>docker exec &lt;id do container&gt; ou &lt;nome&gt; ls -la /usr/share/nginx/html\n</code></pre> <ul> <li>Como fa\u00e7o para visualizar o log de um container?</li> </ul> <pre><code>docker logs &lt;id do container&gt; ou &lt;nome&gt;\n</code></pre> <ul> <li>Como fa\u00e7o para visualizar status do meu container?</li> </ul> <pre><code>docker stats &lt;id do container&gt; ou &lt;nome&gt;\n</code></pre> <ul> <li>Como fa\u00e7o para visualizar informa\u00e7\u00f5es detalhadas de um container?</li> </ul> <pre><code>docker inspect &lt;id do container&gt; ou &lt;nome&gt;\n</code></pre>"},{"location":"c1/managing-containers/","title":"Gerenciando containers","text":"<p>Para podermos utilizar os comandos de stop e start, por exemplo, precisamos ter um container que de fato esta parado ou rodando, certo? ent\u00e3o agora vamos rodar um container um pouco mais \"complexo\".</p> <p>Aten\u00e7\u00e3o, localhost \u00e9 para m\u00e1quinas que est\u00e3o com Docker rodando diretamente no \"bare metal\", se estiver utilizando VM acesse o IP desta VM, algo como 192.168.25.100 - 10.100.111.222</p> <p>Abra um browser e acesse http://localhost:45000 e a p\u00e1gina n\u00e3o foi localizada, certo?</p> <p>Execute o seguinte comando:</p> <pre><code>docker container run --detach --publish 45000:80 nginx\n</code></pre> <p>Agora abra novamente o endere\u00e7o http://localhost:45000 - Magic!</p> <p>Certo, agora temos um servidor web funcionando com apenas um comando na porta 45000 e com isso em funcionamento podemos utilizar os comandos de stop e start.</p> <p>Vamos parar o container:</p> <pre><code>docker container stop &lt;id do container&gt;\n</code></pre> <p>Acesse novamente o seu browser e tente acessar a porta 45000.</p> <p>Vamos subir novamente o container com o comando:</p> <pre><code>docker container start &lt;id do container&gt;\n</code></pre>"},{"location":"c1/manipulate-containers/","title":"Manipulando containers","text":"<p>O comando que executamos incialmente docker container run alpine hostname \u00e9 o mais b\u00e1sico poss\u00edvel para termos um container em \"funcionamento\". O \"funcionamento\" entre aspas \u00e9 o que iremos discutir neste momento.</p> <p>Antes tentamos remover a imagem alpine e obtivemos um erro, mas o que causou o erro? Foi devido que o container est\u00e1 rodando. Ent\u00e3o como sabemos se um container est\u00e1 rodando? ou melhor, como sabemos o \"status\" de um container?</p> <p>Utilize o comando:</p> <pre><code>docker container &lt;comando&gt;\n</code></pre> <ul> <li>Queremos listar containers?</li> </ul> <pre><code>docker container ls\n</code></pre> <ul> <li>Queremos parar?</li> </ul> <pre><code>docker container stop &lt;nome do container&gt; ou &lt;id do container&gt;\n</code></pre> <ul> <li>Queremos iniciar?</li> </ul> <pre><code>docker container start &lt;nome do container&gt; ou &lt;id do container&gt;\n</code></pre> <p>Para a lista de comandos que podemos utilizar, simplesmente execute:</p> <pre><code>docker container\n</code></pre>"},{"location":"c1/running-containers/","title":"Rodando containers","text":"<p>Verifique se est\u00e1 com docker corretamente funcionando, para isso execute o comando:</p> <pre><code>docker version\n</code></pre> <p>Sua sa\u00edda deve ser algo parecido com:</p> <pre><code>rafael @ nazgul ~\n\u2514\u2500 $ \u25b6 docker version\nClient:\n Version:   17.12.0-ce\n API version:   1.35\n Go version:    go1.9.2\n Git commit:    c97c6d6\n Built: Wed Dec 27 20:03:51 2017\n OS/Arch:   darwin/amd64\n\nServer:\n Engine:\n  Version:  17.12.0-ce\n  API version:  1.35 (minimum version 1.12)\n  Go version:   go1.9.2\n  Git commit:   c97c6d6\n  Built:    Wed Dec 27 20:12:29 2017\n  OS/Arch:  linux/amd64\n  Experimental: true\n</code></pre>"},{"location":"c1/running-containers/#comandos","title":"Comandos","text":"<p>Para verificar todos os comandos proporcionados por Docker, simplesmente digite:</p> <pre><code>docker\n</code></pre> <p>Importante: n\u00e3o esque\u00e7a que a linha de comando (CLI) \u00e9 sua melhor amiga, caso n\u00e3o souber como um comando continua, ou seja, op\u00e7\u00f5es deste comando, simplesmente digite:</p> <pre><code>docker &lt;comando&gt; --help\n</code></pre>"},{"location":"c1/running-containers/#rodando-um-container","title":"Rodando um container","text":"<pre><code>docker container run alpine hostname\n</code></pre> <p>Voc\u00ea provavelmente teve uma resposta com letras e n\u00fameros, algo como: 7ed46aef747a. O que acabamos de ver aqui \u00e9 o nome do container no momento que voc\u00ea o executou.</p> <p>Vamos explicar por partes o que o comando acima faz:</p> <ul> <li>docker container run executa um container</li> <li>alpine \u00e9 o nome da imagem que estamos Utilizando</li> <li>hostname \u00e9 o comando que \u00e9 executado dentro do container, por isso obtemos aquele conjunto de n\u00fameros e letras como resposta quando executamos o comando.</li> </ul> <p>O que iremos ver agora \u00e9:</p> <ul> <li>Executando o comando acima algumas vezes, o resultado mudou?</li> </ul>"},{"location":"c1/running-containers/#utilizando-imagens","title":"Utilizando imagens","text":"<p>Tudo que iremos executar em um container, vem de uma imagem e essa imagem pode ser uma que voc\u00ea mesmo criou ou uma imagem oficial, como foi o nosso caso acima como o Alpine.</p> <p>Apenas por conhecimento, Alpine \u00e9 uma distribui\u00e7\u00e3o Linux super pequena que neste exato momento em sua vers\u00e3o 3.7.0 tem uma iso de 130MB e o mesmo vale para sua imagem para container, acredite, s\u00e3o 4.5MB de tamanho.</p> <p>Execute o comando:</p> <pre><code>docker images\n</code></pre> <p>E o resultado deve ser algo assim:</p> <pre><code>rafael @ nazgul ~\n\u2514\u2500 $ \u25b6 docker images\nREPOSITORY                          TAG                    IMAGE ID            CREATED             SIZE\ngolang                              1.10.0-alpine3.7       85256d3905e2        7 weeks ago         376MB\nmaven                               3.5.2-jdk-8            31eec910d005        7 weeks ago         748MB\nubuntu                              16.04                  0458a4468cbc        2 months ago        112MB\nubuntu                              latest                 0458a4468cbc        2 months ago        112MB\nraffaeldutra/gohugo                 latest                 7d6cac06f35c        2 months ago        1.11GB\ngolang                              latest                 3858fd70eed2        2 months ago        735MB\npython                              2.7-alpine             0781c116c406        2 months ago        72.4MB\npython                              3.6.4-alpine3.7        4b00a94b6f26        2 months ago        83.4MB\nalpine                              3.4                    c7fc7faf8c28        3 months ago        4.82MB\nalpine                              latest                 3fd9065eaf02        3 months ago        4.15MB\nnginx                               latest                 3f8a4339aadd        3 months ago        108MB\njenkins                             latest                 5fc84ab0b7ad        3 months ago        809MB\njenkins                             2.60.3-alpine          2ad007d33253        5 months ago        223MB\nmaven                               3.5.2-jdk-8-alpine     293423a981a7        5 months ago        116MB\njava                                openjdk-8-jdk-alpine   3fd9dd82815c        13 months ago       145MB\njava                                8u102-jre              13f413e924a3        17 months ago       309MB\n</code></pre> <p>O que iremos ver agora \u00e9:</p> <ul> <li>Como procurar uma imagem?</li> </ul> <pre><code>docker search &lt;imagem&gt;\n</code></pre> <ul> <li>Como remover uma imagem?</li> </ul> <pre><code>docker rmi alpine\n</code></pre> <p>Aqui iremos obter um erro, pois temos aquele primeiro container -- docker container run alpine hostname -- em funcionamento e n\u00e3o \u00e9 poss\u00edvel remover uma imagem onde h\u00e1 containers rodando.</p> <ul> <li>Como saber se a imagem que vou utilizar \u00e9 uma imagem oficial?</li> </ul> <pre><code>docker search ubuntu\n</code></pre> <ul> <li>Como baixamos uma imagem?</li> </ul> <pre><code>docker pull ubuntu\n</code></pre> <p>e para baixarmos uma vers\u00e3o espec\u00edfica, como Ubuntu 18.04? Para isso passe ap\u00f3s o : a vers\u00e3o que quer utilizar</p> <pre><code>docker pull ubuntu:18.04\n</code></pre>"},{"location":"c2/creating-image-no-dockerfile/","title":"Criando imagem sem Dockerfile","text":"<p>Sim, n\u00f3s tamb\u00e9m podemos criar imagens sem precisar de Dockerfile. Vamos ver o seguinte:</p> <pre><code>docker container run --interactive --tty ubuntu /bin/bash\n</code></pre> <p>Com este comando n\u00f3s \"entramos\" no container. Dentro do container podemos fazer o que quisermos, como adicionar arquivos, remover arquivos, adicionar pacotes e etc.</p> <p>Vamos ent\u00e3o adicionar um pacote. No container, execute:</p> <pre><code>apt-get update &amp;&amp; apt-get install curl\n</code></pre>"},{"location":"c2/creating-image/","title":"Criando uma imagem","text":"<p>Para criamos nossa imagem, precisamos de um arquivo Dockerfile conforme vistoacima. Com este arquivo podemos criar nossas pr\u00f3prias imagens de uma forma organizada e automatizada.</p> <p>Para criarmos ela, devemos executar o comando</p> <pre><code>docker image build --tag nomeDaImagemQueDeseja:versao.1 .\n</code></pre> <p>Devemos atentar par duas coisas aqui:</p> <p>1 - O arquivo Dockerfile deve estar (mas podemos passar par\u00e2metro, mas n\u00e3o vamos discutir isso agora) no mesmo diret\u00f3rio onde voc\u00ea est\u00e1 executando o comando.</p> <p>2 - Existe sim um . (ponto) final no comando, ele diz de uma maneira simplificada que nosso Dockerfile est\u00e1 neste diret\u00f3rio.</p> <p>\u00c9 realmente simples gerarmos uma imagem com o nosso arquivo, segue um exemplo de como isto pode ser feito.</p> <pre><code>docker image build --tag fossday/nginx:0.1 .\n</code></pre> <p>Agora vamos executar o nosso container baseado na imagem que acabamos de gerar.</p> <pre><code>docker container run --interactive --tty --publish 46000:80 fossday/nginx:0.1 /bin/bash\n</code></pre> <p>Vamos acessa a url e ver o que nos espera, http://localhost:46000</p> <ul> <li>O que aconteceu?</li> <li>Qual o motivo de alterarmos o arquivo index.html em nossa m\u00e1quina e nada aconteceu na p\u00e1gina?</li> </ul>"},{"location":"c2/dockerfile/","title":"Dockerfile","text":"<p>Chegamos ent\u00e3o ao arquivo principal de Docker, o t\u00e3o conhecido Dockerfile. Dockerfile \u00e9 um simples arquivo texto que contem todos os comandos para gerar uma imagem, apenas isso em sua forma mais resumida.</p> <p>Se voc\u00ea j\u00e1 conhece um pouco de <code>CLI (Command Line Interface)</code> de GNU/Linux, provavelmente n\u00e3o ter\u00e1 nenhum problema para utilizar Dockerfile, pois ele \u00e9 basicamente comando que voc\u00ea j\u00e1 usa.</p> <p>Aqui est\u00e1 a lista dos comandos que voc\u00ea pode utilizar dentro do seu arquivo. Vamos explicar rapidamente o que cada um faz.</p> <ul> <li><code>FROM</code> - define a imagem base para voc\u00ea iniciar sua nova imagem.</li> <li><code>LABEL</code> - aqui \u00e9 poss\u00edvel definir algumas informa\u00e7\u00f5es para melhor organiza\u00e7\u00e3o de suas imagens, voc\u00ea pode usar quantas labels quiser.</li> <li><code>ENV</code> - vari\u00e1veis de ambiente que ser\u00e3o utilizadas dentro do container quando voc\u00ea invocar a imagem.</li> <li><code>RUN</code> - aqui ir\u00e3o entrar todos os comandos que deseja executar assim que iniciar a buildar sua imagem.</li> <li><code>WORKDIR</code> - de onde ser\u00e3o executados os comandos, este comando \u00e9 um path apenas.</li> <li><code>VOLUME</code> - possibilita o acesso de um diret\u00f3rio na sua m\u00e1quina real.</li> <li><code>USER</code> - qual usu\u00e1rio ir\u00e1 executar os comandos dentro da imagem, o padr\u00e3o \u00e9 root.</li> <li><code>ADD ou COPY</code> - copia arquivos e diret\u00f3rios de sua m\u00e1quina local para dentro da imagem.</li> <li><code>EXPOSE</code> - exp\u00f5e uma porta para ser acessada publicamente, como a porta 80, por exemplo</li> <li><code>CMD</code> - executa um comando assim que voc\u00ea invocar a imagem.</li> <li><code>ENTRYPOINT</code> - parecido com o <code>CMD</code>, mas aqui normalmente voc\u00ea coloca um script para ser iniciado.</li> </ul> <p>Aqui um exemplo utilizando como base a imagem Nginx que j\u00e1 estav\u00e1mos utilizando anteriormente com o m\u00e1ximo de comandos que o Dockerfile suporta e que vimos acima.</p> <pre><code>FROM nginx:latest\n\nLABEL description=\"Docker imagem que ser\u00e1 gerada no nosso exmeplo.\"\nLABEL maintainer=\"Rafael Dutra &lt;raffaeldutra@gmail.com&gt;\"\n\nENV FOSSDAY Lajeado\nENV QUANDO 5/5 2018\n\nRUN apt-get update &amp;&amp; \\\n    apt-get install git --yes\n\nADD index.html /usr/share/nginx/html/index.html\n\nEXPOSE 80\n\nCMD [\"nginx\", \"-g\", \"daemon off;\"]\n</code></pre>"},{"location":"c3/storage-drivers/","title":"Storage drivers","text":"<p>Antes de iniciarmos com volumes, \u00e9 realmente importante entedermos um pouco como funcionam as imagens, pois como foi dito em algum momento, um container s\u00f3 existe se houver uma imagem (em uma forma resumida).</p> <p>Storage driver permitem que voc\u00ea crie dados em uma camada de escrita/grava\u00e7\u00e3o do seu container. O importante aqui neste momento \u00e9: quando contianer parar, nenhum dado ser\u00e1 persistifo -- leia-se gravado em disco.</p> <p></p>"},{"location":"c3/storage-drivers/#imagens-e-camadas-layers","title":"Imagens e camadas (layers)","text":"<p>Uma imagem Docker \u00e9 criada em v\u00e1rias camadas e cada camada representa uma instru\u00e7\u00e3o do seu Dockerfile.</p> <p>Vejamos o Dockerfile de exemplo abaixo:</p> <pre><code>FROM alpine:3.7\n\nADD /etc/motd /root/meu-motd\n\nRUN mkdir -p /root/arquivos/leiame\n\nCMD cat /root/meu-motd\n</code></pre> <p>Cada uma dessas linhas acima representam uma camada (layer). O importante aqui \u00e9 entender que cada um desses comandos gera uma camada de diferen\u00e7a em rela\u00e7\u00e3o a outra, ou seja, quando o comando FROM foi executado, ele gerou uma camada (layer) X. O comando ADD gerou uma outra camada com seus arquivos gerando uma camada Y e assim respectivamente para os outros comandos.</p> <p>Essas camandas (layers) s\u00e3o empilhadas uma em cima ds outras e quando voc\u00ea inicia um novo container voc\u00ea simplesmente adiciona uma nova layer de grava\u00e7\u00e3o em cima de todas as outras que j\u00e1 existiam. Se por algum motivo voc\u00ea entrar neste container e modificar qualquer arquivo l\u00e1 dentro, como provavelmente j\u00e1 fizemos em algum exerc\u00edcio anterior, todas as modifica\u00e7\u00f5es ficam nesta nova camada que voc\u00ea criou ao executar seu container.</p> <p>Vejamos esta imagem abaixo:</p> <p></p> <p>Imagem retirada da documenta\u00e7\u00e3o oficial: https://docs.docker.com/storage/storagedriver/images/container-layers.jpg</p> <p></p>"},{"location":"c3/storage-drivers/#containers-e-camadas-layers","title":"Containers e camadas (layers)","text":"<p>A principal e maior diferen\u00e7a entre um container e uma imagem \u00e9 aquela camada de escrita que acabamos de mencionar acima (camada mais alta do diagrama), aquela onde voc\u00ea pode modificar qualquer coisa dentro de um container que \u00e9 onde essas modifica\u00e7\u00f5es ser\u00e3o gravadas.</p> <p>Quando seu container for deletado essa camada de cima tamb\u00e9m \u00e9 removida por\u00e9m as camadas de baixo ir\u00e3o permanecer -- por isso muito cuidado com os bancos de dados que ir\u00e1 levantar, ou ainda os dados que voc\u00ea n\u00e3o pode perder, pois usando o padr\u00e3o de um container, voc\u00ea ir\u00e1 perder tudo -- e aqui tamb\u00e9m reside uma beleza super interessante: voc\u00ea usar o reaproveitamento das camadas de baixo, veja a imagem abaixo:</p> <p></p> <p>Imagem retirada da documenta\u00e7\u00e3o oficial: https://docs.docker.com/storage/storagedriver/images/sharing-layers.jpg</p> <p></p>"},{"location":"c3/storage-drivers/#usando-volumes","title":"Usando Volumes","text":"<p>Chegou a hora de brincar um pouco com volumes. Temos dois \"modelos\" de como utilizar containers aqui:</p> <ol> <li>Mapeando diret\u00f3rio do nosso host Aqui podemos escolher o que queremos do nosso host e mapearmo este diret\u00f3rio l\u00e1 pra dentro do container. Exemplo:</li> </ol> <pre><code>docker container run --rm --volume /tmp:/root/tmp alpine /bin/sh -c 'echo Eu sou o container de nome $(hostname) &gt; /root/tmp/meu-querido-container'\n</code></pre> <ol> <li>Mapeando dados de um container</li> </ol>"},{"location":"c3/volumes/","title":"Volumes","text":"<p>Volumes s\u00e3o totalmente gerenciados e criados por Docker e voc\u00ea pode cri\u00e1-los com comandos, ou ainda, Docker pode criar este volume durante a cria\u00e7\u00e3o do servi\u00e7o.</p> <p>.Comando para criar um volume</p> <pre><code>$ docker volume create &lt;nome do volume&gt;\n</code></pre> <p>.Exemplo de como criar um volume e cham\u00e1-lo de dados.</p> <pre><code>$ docker volume create dados\n</code></pre> <p>Para listar os volumes.</p> <pre><code>$ docker volume ls\n</code></pre> <p>Com a seguinte sa\u00edda:</p> <pre><code>DRIVER              VOLUME NAME\nlocal               dados\nlocal               e8bf838bebbe3576313a6b37a26ab93d1fbb4865174710d9cb4d80366e85c674\n</code></pre> <p>Caso n\u00e3o seja espec\u00edficado nenhum argumento para dar nome ao seu volume, um hash ser\u00e1 gerado, conforme exemplo acima onde temos o hash com \u00ednicio <code>e8bf83..</code>.</p> <p>Para saber onde foi gerado este diret\u00f3rio com seu volume, \u00e9 necess\u00e1rio inspecionar este volume.</p> <p>Para inspecionar um volume utilize o comando inspect</p> <pre><code>$ docker volume inspect dados`\n</code></pre> <p>Com a seguinte sa\u00edda:</p> <pre><code>[\n    {\n        \"CreatedAt\": \"2019-01-30T14:00:29-02:00\",\n        \"Driver\": \"local\",\n        \"Labels\": {},\n        \"Mountpoint\": \"/var/lib/docker/volumes/dados/_data\",\n        \"Name\": \"dados\",\n        \"Options\": {},\n        \"Scope\": \"local\"\n    }\n]\n</code></pre> <p>Toda vez que for criado um volume, este volume \u00e9 guardado em um diret\u00f3rio no Docker host e esta estrutura \u00e9 que ser\u00e1 enviada para dentro do container, mas a grande diferen\u00e7a aqui para <code>bind mounts</code> \u00e9 que todo os dados criados neste volume s\u00e3o gerenciados pelo Docker.</p> <p>Todos os volumes criados podem ser usados por v\u00e1rios containers ao mesmo tempo, ou ainda, quando n\u00e3o houver containers utilizando este volume, ele ficar\u00e1 em espera para quando for preciso utiliz\u00e1-lo. O importante aqui \u00e9 que seu volume sempre estar\u00e1 por sua espera para utilizar.</p> <p>Volumes tem v\u00e1rias vantagens de utilizar do que <code>bind mounts</code>:</p> <ul> <li>F\u00e1ceis de fazer backups ou fazer migra\u00e7\u00f5es.</li> <li>\u00c9 poss\u00edvel gerenciar volumes usando a CLI do Docker ou utilizando a API.</li> <li>Volumes funcionam em Linux e Windows.</li> <li>Volumes s\u00e3o mais seguros de compartilhar entre v\u00e1rios containers.</li> <li>Volumes cont\u00eam v\u00e1rios tipos de drivers para trabalhar localmente, provedores de Cloud Computing (AWS, Google Cloud, Azure e outros), para encriptar seu conte\u00fado ou adicionar funcionalidades.</li> <li>Volumes s\u00e3o geralmente uma escolha melhor do que persistir dados na camada de escrita do container, pois o volume n\u00e3o ir\u00e1 aumentar o tamanho do container que o est\u00e1 uando, e o conte\u00fado do volume \u00e9 feito totalmente fora de um container.</li> </ul> <p>Para utilizar volumes em linha de comando em Docker, voc\u00ea deve passar o par\u00e2metro <code>-v</code>. Vejamos um exemplo:</p> <pre><code>$ docker run \\\n--rm \\\n--volume ubuntu-volume:/tmp ubuntu \\\nmkdir /tmp/novo-diretorio\n</code></pre> <p>Com este comando, foi criado um novo diret\u00f3rio em <code>/tmp/novo-diretorio</code> dentro do container, por\u00e9m como estamos usando volumes, podemos achar este dado diretamente em nosso host onde persistimos o dado.</p> <p>Verificando o caminho do volume</p> <pre><code>$ docker volume inspect ubuntu-volume\n</code></pre> <p>Com a seguinte sa\u00edda.</p> <pre><code>[\n    {\n        \"CreatedAt\": \"2019-01-30T19:40:29-02:00\",\n        \"Driver\": \"local\",\n        \"Labels\": null,\n        \"Mountpoint\": \"/var/lib/docker/volumes/ubuntu-volume/_data\",\n        \"Name\": \"ubuntu-volume\",\n        \"Options\": null,\n        \"Scope\": \"local\"\n    }\n]\n</code></pre> <p>Com o comando abaixo, verifique se o diret\u00f3rio foi criado.</p> <pre><code>$ sudo ls -la /var/lib/docker/volumes/ubuntu-volume/_data`\n</code></pre> <p>Vamos criar mais dois containers apontando para este mesmo volume, mas, em um destes dois containers, vamos criar alguns arquivos, e no outro container devemos poder listar estes novos arquivos.</p> <pre><code>$ docker run \\\n--interactive \\\n--tty \\\n--volume ubuntu-volume:/tmp ubuntu\n</code></pre> <p>Liste o conte\u00fado do diret\u00f3rio <code>/tmp</code></p> <pre><code>root@a83a59e4555c:/# ls -la /tmp/\ntotal 12\ndrwxrwxrwt 3 root root 4096 Jan 30 21:40 .\ndrwxr-xr-x 1 root root 4096 Jan 30 22:07 ..\ndrwxr-xr-x 2 root root 4096 Jan 30 21:40 novo-diretorio\n</code></pre> <p>Abra um novo terminal e rode um novo container, criando alguns arquivos dentro do diret\u00f3rio <code>tmp</code>.</p> <p>Criando um novo container</p> <pre><code>$ docker run \\\n--interactive \\\n--tty \\\n--volume ubuntu-volume:/tmp ubuntu\n</code></pre> <p>Criando novos diret\u00f3rios no diret\u00f3rio <code>/tmp</code></p> <pre><code>cd /tmp\nroot@71df4a42bc32:/tmp# mkdir -p diretorio-a diretorio-b diretorio-c/subdiretorio-a\n</code></pre> <p>Liste no primeiro container o diret\u00f3rio <code>tmp</code>.</p> <pre><code>root@a83a59e4555c:/# ls -la /tmp/\ntotal 24\ndrwxrwxrwt 6 root root 4096 Jan 30 22:13 .\ndrwxr-xr-x 1 root root 4096 Jan 30 22:07 ..\ndrwxr-xr-x 2 root root 4096 Jan 30 22:13 diretorio-a\ndrwxr-xr-x 2 root root 4096 Jan 30 22:13 diretorio-b\ndrwxr-xr-x 3 root root 4096 Jan 30 22:13 diretorio-c\ndrwxr-xr-x 2 root root 4096 Jan 30 21:40 novo-diretorio\n</code></pre>"},{"location":"c3/volumes/#bind-mounts","title":"Bind Mounts","text":"<p>Bind mounts s\u00e3o menos eficientes que volumes, pois o diret\u00f3rio ou arquivo que est\u00e1 em sua m\u00e1quina ser\u00e1 apontada para dentro do container. Se estiver iniciando um novo projeto, prefira utilizar volumes no lugar de bind mounts.</p> <p>Na vers\u00e3o 17.06 do Docker foi introduzido um par\u00e2metro chamado de --mount para containers. Recomenda-se o uso de --mount no lugar do par\u00e2metro -v pois --mount \u00e9 mais explicito e f\u00e1cil de utilizar.</p> <p>Assumindo que voc\u00ea tem um diret\u00f3rio chamado teste e com um arquivo qualquer dentro deste diret\u00f3rio, vamos rodar o comando para montar estes objetos dentro do container.</p> <p>Para utilizar bind mounts apenas passe este argumento quando chamar um novo container:</p> <pre><code>$ docker run -it \\\n--mount type=bind,source=/tmp/teste,target=/tmp/teste \\\nalpine \\\nls -la /tmp/teste\n</code></pre> <p>Com a seguinte sa\u00edda:</p> <pre><code>total 4\ndrwxr-xr-x    3 root     root            96 Feb 17 00:30 .\ndrwxrwxrwt    1 root     root          4096 Feb 17 00:30 ..\ndrwxr-xr-x    2 root     root            64 Feb 17 00:30 diretorio-a\n</code></pre>"}]}